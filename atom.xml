<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Victor Zhao's Blog]]></title>
  <link href="http://victorzhao1990.github.io/atom.xml" rel="self"/>
  <link href="http://victorzhao1990.github.io/"/>
  <updated>2014-11-06T16:33:31-05:00</updated>
  <id>http://victorzhao1990.github.io/</id>
  <author>
    <name><![CDATA[Victor Zhao]]></name>
    <email><![CDATA[xinyunzhao@msn.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode Max Points on a Line]]></title>
    <link href="http://victorzhao1990.github.io/blog/2014/11/06/leetcode-max-points-on-a-line/"/>
    <updated>2014-11-06T11:21:41-05:00</updated>
    <id>http://victorzhao1990.github.io/blog/2014/11/06/leetcode-max-points-on-a-line</id>
    <content type="html"><![CDATA[<p><a href="https://oj.leetcode.com/discuss/9929/a-java-solution-with-notes">https://oj.leetcode.com/discuss/9929/a-java-solution-with-notes</a></p>

<pre><code>import java.util.HashMap;
import java.lang.Math;

// Definition for a point.
class Point {
    int x;
    int y;
    Point() { x = 0; y = 0; }
    Point(int a, int b) { x = a; y = b; }
}
/*  
* 
*  O(n^2) time.
*
*  A line is determined by two factors,say y=ax+b
*
*  If two points(x1,y1) (x2,y2) are on the same line(Of course).
*  Consider the gap between two points.
*  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant
*  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b
*  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a
*  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a
*  So we can use y0&amp;x0 to track a line;
*/
public class Solution {
    // Point[] points;
    public int maxPoints(Point[] points) {
        if (points == null) {
            return 0;
        }

        // If there are only two points or less, just return the number of these points.
        if (points.length &lt;= 2) {
            return points.length;
        }
        // The value that is used to return for the final number of points
        int result = 0;
        // Store the number points in a variable
        int n = points.length;
        // Use a nested HashMap to store the information for x0, y0 and the number of points that reside on this line.
        // The format is HashMap&lt;x0, HashMap&lt;y0, number&gt;&gt;
        HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            // If there are several points that have the same coordinates, use a counter called overlap to record it.
            int overlap = 0;
            // Since it use only one nested hashmap to store the information of the point starting from one specific i index pairing with 
            // all other points starting from i + 1 to n, the map need to be refresh during the update of i. 
            map.clear();
            // Use variable max to record the maximum value in every iteration/lookup in the hashmap
            int max = 0;
            for (int j = i + 1; j &lt; n; j++) {
                int x = points[i].x - points[j].x;
                int y = points[i].y - points[j].y;
                if ((x == 0) &amp;&amp; (y == 0)) {
                    overlap++;
                    continue;
                }
                // Use gcd to normalize the slope for each point
                int gcd = generateGCD(x, y);
                if (gcd != 0) {
                    x /= gcd;
                    y /= gcd;
                }
                // If map doesn't include one specific point, add it.
                if (map.containsKey(x)) {
                    if (map.get(x).containsKey(y)) {
                        map.get(x).put(y, map.get(x).get(y) + 1);
                    } else {
                        map.get(x).put(y, 1);
                    }
                } else {
                    HashMap&lt;Integer, Integer&gt; innerMap = new HashMap&lt;&gt;();
                    innerMap.put(y, 1);
                    map.put(x, innerMap);
                }
                max = Math.max(max, map.get(x).get(y));
            }
            // The number of overlap should be included.
            result = Math.max(result, max + overlap + 1);
        }
        return result;
    }

    private int generateGCD(int a, int b) {
        if (b == 0) {
            return a;
        } else {
            return generateGCD(b, a % b);
        }
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go for Ten Interviews]]></title>
    <link href="http://victorzhao1990.github.io/blog/2014/10/02/go-for-ten-interviews/"/>
    <updated>2014-10-02T12:32:52-04:00</updated>
    <id>http://victorzhao1990.github.io/blog/2014/10/02/go-for-ten-interviews</id>
    <content type="html"><![CDATA[<p>Just have failed the first two. There are still eight left.</p>

<p>You are going to fail the first five, and nail the last five, which are FLAG and so on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Behaviour Is Traded by Sacrificing]]></title>
    <link href="http://victorzhao1990.github.io/blog/2014/09/28/behaviour-is-traded-by-sacrificing/"/>
    <updated>2014-09-28T22:18:43-04:00</updated>
    <id>http://victorzhao1990.github.io/blog/2014/09/28/behaviour-is-traded-by-sacrificing</id>
    <content type="html"><![CDATA[<p>Dignity could not be harmed by the injury that you get. On the contrary, injuries only make you stronger. As long as it has not killed you, you are just becoming strong than before.</p>

<p>What doesn&rsquo;t kill you, simply makes you, stranger, but, more importantly, much stronger.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finally, the Go-mode!]]></title>
    <link href="http://victorzhao1990.github.io/blog/2014/09/11/finally/"/>
    <updated>2014-09-11T12:17:41-04:00</updated>
    <id>http://victorzhao1990.github.io/blog/2014/09/11/finally</id>
    <content type="html"><![CDATA[<p>Efforts have been made.
<img src="http://victorzhao1990.github.io/images/go-mode.png" alt="Go-mode" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C U Tomorrow.]]></title>
    <link href="http://victorzhao1990.github.io/blog/2014/09/04/c-u-tomorrow/"/>
    <updated>2014-09-04T19:55:58-04:00</updated>
    <id>http://victorzhao1990.github.io/blog/2014/09/04/c-u-tomorrow</id>
    <content type="html"><![CDATA[<p>Never say no to the big thing that hasn&rsquo;t come yet.</p>

<p><img src="http://victorzhao1990.github.io/images/boeing_logo-copy.gif" alt="Boeing Icon" /></p>
]]></content>
  </entry>
  
</feed>
